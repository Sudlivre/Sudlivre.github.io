---
title: Golang基础语法之四
date: 2019-09-29 14:16:52
tags: 
- Golang
- Golang Days
categories:
- Golang
---

## 函数

### 函数定义

```go
// 声明
func FuncName() {
    return
}
// 调用
FuncName()
```

函数调用的实参和形参必须一一对应，顺序，个数，类型

### 可变参数

```go
func myFunc(arg ...int) {
    for _, n := range arg {
        fmt.Println(n)
    }
}

myFunc(2,3,4)
s1 := []int{1,2,34,5}
myFunc(s1...)
```

### 参数传递

- 值传递 传递的是参数的副本
- 引用传递 传递的是参数的地址

### 函数中变量的作用域

作用域在函数中

## defer

延迟函数或者方法的执行，等待外围函数执行完在执行defer中的内容。

如果存在多个defer，执行defer依据类似栈结构，先进后出。

defer函数调用时，函数的参数已经传递。

当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。

当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。当外围函数中的代码引发运行恐慌时，只有其中所有延迟函数都执行完毕后，该运行时恐慌才会被扩展至调用函数。

### 匿名函数

Golang支持函数式编程

```go
func () {
    fmt.Println("aaa")
}()

func3 = func () {
    fmt.Println("aaa")
}
```

### 回调函数

函数作为另一个函数的参数，发生调用。

### 闭包

一个外层函数中，有内层函数，该内层函数中，会操作外层函数的局部变量，并且该外层函数的返回值就是这个内层函数。

这个内层函数和外层函数的局部变量，统称为闭包结构。

局部变量的生命周期会发生改变，正常的局部变量随着函数的调用而创建，随着函数的结束而销毁。但闭包结构不会随着函数的结束而销毁，因为内层函数还要继续使用。
